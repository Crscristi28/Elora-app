# ğŸ—ï¸ Omnia Architecture & Roadmap

**Date:** 2025-10-10
**Status:** Living document - updated as we implement features

---

## ğŸ“‹ Table of Contents

1. [The Core Problem](#-the-core-problem-google-api-limitations)
2. [The Solution: Background Agents](#-the-solution-background-agent-architecture)
3. [Proof of Concept: Parallel Summarization](#-proof-of-concept-parallel-summarization)
4. [Roadmap](#-roadmap)
5. [Technical Details](#-technical-details)
6. [Lessons Learned](#-lessons-learned)

---

## ğŸš¨ The Core Problem: Google API Limitations

### The Restriction

Google Gemini API has a **critical limitation**:

```
âŒ CANNOT COMBINE in a single request:
   - Google Search (grounding)
   - Function Calling (tools like generate_image, generate_pdf, etc.)
```

**Official error:**
```
googleGrounding and function calling cannot be used at the same time
```

### Real-World Impact

**User request:** "Find latest React trends and create a comparison chart"

**Current flow (broken):**

```
1. User: "Find React trends + make chart"
2. Omnia calls Gemini with:
   - search: true  âœ…
   - tools: [generate_chart]  âŒ ERROR!
3. Request fails
4. User must ask AGAIN: "Now create the chart"
```

**Why this sucks:**
- âŒ Broken user experience (2-step process for 1 task)
- âŒ Extra latency (2 separate API calls)
- âŒ Context loss between requests
- âŒ User frustration
- âŒ Limits what Omnia can do

### Use Cases That Don't Work

Without agents, these **don't work** in a single response:

| User Request | Why It Fails |
|--------------|--------------|
| "Search React trends + make chart" | Search + tool conflict |
| "Find top restaurants + show on map" | Search + tool conflict |
| "Research competitors + create comparison table" | Search + tool conflict |
| "Get stock prices + generate PDF report" | Search + tool conflict |
| "Analyze code + generate diagram" | Search + tool conflict |

**Bottom line:** User can have EITHER search OR tools, not both. ğŸ˜¢

---

## ğŸ’¡ The Solution: Background Agent Architecture

### Core Concept

**Split work between TWO Gemini instances:**

1. **Main Model (Gemini 2.5 Flash)** - Handles search + text response
2. **Background Agent (Gemini 2.5 Flash-Lite)** - Handles tools (charts, images, PDFs)

**They run in PARALLEL!** ğŸš€

### Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User: "Search React trends + make chart"        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Main Model    â”‚
         â”‚  (Flash 2.5)   â”‚
         â”‚                â”‚
         â”‚  âœ… Search     â”‚
         â”‚  âœ… Text       â”‚
         â”‚  âŒ No tools   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â”‚ Sends agent request
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Agent Model    â”‚
         â”‚ (Flash-Lite)   â”‚
         â”‚                â”‚
         â”‚  âŒ No search  â”‚
         â”‚  âœ… Tools      â”‚
         â”‚  âœ… Fast       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  BOTH RUN IN PARALLEL!    â”‚
    â”‚                            â”‚
    â”‚  Main: Streams text        â”‚
    â”‚  Agent: Generates chart    â”‚
    â”‚                            â”‚
    â”‚  User sees BOTH together   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How It Works

**Step-by-step:**

1. **User sends message:** "Find React trends + make chart"

2. **App.jsx detects intent:**
   - Needs search? â†’ Use main model
   - Needs tools? â†’ Also start agent

3. **Main model (Flash 2.5):**
   ```javascript
   const result = await geminiService.sendMessage(context, {
     search: true,   // âœ… Search enabled
     tools: []       // âŒ No tools
   });
   // Streams: "Based on search, React trends are..."
   ```

4. **Agent (Flash-Lite) runs in parallel:**
   ```javascript
   fetch('/api/background-agent', {
     method: 'POST',
     body: JSON.stringify({
       task: 'generate_chart',
       data: extractedFromSearch
     })
   })
   .then(result => {
     // Add chart to message when ready
     setMessages(prev => prev.map(/* add chart */));
   });
   ```

5. **User sees:**
   - Text response (from main model) âœ…
   - Chart (from agent) âœ…
   - Both appear together! ğŸ‰

### Benefits

| Benefit | Description |
|---------|-------------|
| ğŸš€ **No API conflict** | Main = search, Agent = tools (separate requests!) |
| âš¡ **Parallel execution** | Both run at same time = faster! |
| ğŸ’° **Cost optimized** | Agent uses Flash-Lite (6x cheaper!) |
| ğŸ¯ **Better UX** | User gets everything in ONE response |
| ğŸ”§ **Scalable** | Can add more agent types (image, PDF, etc.) |

---

## âœ… Proof of Concept: Parallel Summarization

### We Already Built It!

**Current implementation:**
- Summary creation (Flash-Lite) runs in **BACKGROUND**
- Main response (Flash 2.5) starts **IMMEDIATELY**
- Both finish in parallel

**Code location:** `/src/App.jsx` line 1757-1803

```javascript
// ğŸš€ Start summarization in PARALLEL (no await!)
fetch('/api/summarize', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    previousSummary,
    messages: messagesToSummarize
  })
})
.then(res => res.json())
.then(summaryData => {
  if (summaryData.success) {
    // Update bot message with metadata
    setMessages(prev =>
      prev.map(msg =>
        msg.id === botMessageId
          ? { ...msg, hasMetadata: true, metadata: {...} }
          : msg
      )
    );
  }
})
.catch(error => console.error(error));

console.log('ğŸš€ Summarization started in background, continuing to main response...');

// Main response starts IMMEDIATELY (no wait!)
const result = await geminiService.sendMessage(...);
```

### Production Logs Prove It Works

```
ğŸš€ [SUMMARY] Trigger detected! Creating IN PARALLEL...
ğŸ“Š [SUMMARY] Messages to summarize: 9
ğŸš€ [SUMMARY] Started in background, continuing to main response...
ğŸ¯ [CONTEXT] Using FULL HISTORY
ğŸ¯ [CONTEXT] Messages sent to Gemini: 9
ğŸ¤– Omnia Gemini 2.5 Flash - Google Grounding [STARTED]
...
ğŸ¯ Stream finished, word queue has 69 words [MAIN DONE]
âœ… [SUMMARY] Summary created successfully (parallel) â† Arrived AFTER!
ğŸ“Š [SUMMARY] Compression: 72%
ğŸ“Š [SUMMARY] Metadata added to bot message
```

**Timeline:**
1. âœ… Summarization **started** (background)
2. âœ… Main response **started immediately** (no blocking!)
3. âœ… Main response **finished streaming**
4. âœ… Summary **completed after** and added metadata

### Technical Validation

**No race conditions found:**
- âœ… React state updates are atomic (`setMessages` with callback)
- âœ… Each message has unique ID (no conflicts)
- âœ… Summary metadata saves correctly
- âœ… IndexedDB uses incremental save logic
- âœ… Multiple Gemini instances work fine

**Conclusion:** Parallel execution is **production ready!** ğŸ‰

---

## ğŸ¯ Roadmap

### âœ… Phase 0: Foundation (COMPLETED)

**What we have:**

| Feature | Status | Notes |
|---------|--------|-------|
| Parallel summarization | âœ… Production | Proof-of-concept for agents |
| Keep 4 recent messages | âœ… Production | Context continuity |
| Rich formatting (tables, blockquotes) | âœ… Production | Prompt update |
| Gallery system | âœ… Production | Image management |
| Image generation (Imagen) | âœ… Production | Via tool |
| PDF generation | âœ… Production | Via tool |
| Smart context building | âœ… Production | Summary + recent messages |

### ğŸš€ Phase 1: Background Agent System (COMPLETED! âœ…)

**Goal:** Implement general-purpose background agent infrastructure

**Priority:** HIGH (solves Google API limitation!)

**Status:** âœ… **IMPLEMENTED** (as of 2025-01-15)

**Components built:**

1. âœ… **`/api/background-agent.js`** - Agent endpoint with Flash-Lite
2. âœ… **Parallel execution** - Runs alongside Main Model (proven with summarization POC)
3. âœ… **Tool support** - PDF generation, Image generation (Imagen 4)

**Use cases unlocked:**

| Use Case | Before | After |
|----------|--------|-------|
| "Search React + make chart" | âŒ 2 requests | âœ… 1 response |
| "Find restaurants + show map" | âŒ Impossible | âœ… Parallel |
| "Research + create report" | âŒ Manual steps | âœ… Automatic |
| Gallery image editing | âš ï¸ Sequential | âœ… Parallel |

**Problem discovered:** Background agent runs for EVERY user message (cost inefficient + false positives)

**Solution:** See Phase 1.5 (Intent Classifier) below! ğŸ‘‡

---

### ğŸ§  Phase 1.5: Intent Classifier (READY TO IMPLEMENT!)

**Goal:** AI-based tool orchestration replacing keyword detection

**Priority:** ğŸš¨ **CRITICAL** - Cost optimization + UX improvement

**Status:** âœ… Documentation complete ([/docs/INTENT_CLASSIFIER.md](./INTENT_CLASSIFIER.md))

**Problem solved:**

**Before (keyword detection):**
- âŒ "hledej dokumentaci" triggered PDF generation (false positive!)
- âŒ Background agent runs 10,000Ã—/month ($20/mo) even when not needed
- âŒ No confirmation flow ("MÅ¯Å¾u dostat PDF?" â†’ PDF immediately generated)

**After (Intent Classifier):**
- âœ… AI understands context: "hledej dokumentaci" = search, NOT PDF
- âœ… Agent runs only 2,000Ã—/month ($4/mo) - Intent Classifier filters 80%
- âœ… Confirmation flow: "MÅ¯Å¾u dostat PDF?" â†’ Omnia answers â†’ User confirms â†’ PDF

**Architecture: 3-Component Parallel System**

```
KAÅ½DÃ USER TURN:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Main Model     â”‚  â”‚ Intent          â”‚  â”‚  Tool Agent     â”‚
â”‚  (Omnia)        â”‚  â”‚ Classifier      â”‚  â”‚ (Background)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… VÅ½DY bÄ›Å¾Ã­    â”‚  â”‚ âœ… VÅ½DY sleduje â”‚  â”‚ âš ï¸ PODMÃNÄšNÄš   â”‚
â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚
â”‚ â€¢ Konverzace    â”‚  â”‚ â€¢ AnalÃ½za       â”‚  â”‚ â€¢ PDF/Image     â”‚
â”‚ â€¢ Search        â”‚  â”‚ â€¢ Security      â”‚  â”‚ (jen kdyÅ¾       â”‚
â”‚ â€¢ Streaming     â”‚  â”‚ â€¢ RozhodovÃ¡nÃ­   â”‚  â”‚  tÅ™eba)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Components:**

1. **`/api/intent-classifier.js`** (NEW)
   - Model: Gemini 2.0 Flash Lite ($0.075/1M input tokens)
   - Input: Current message + 10-15 recent messages + pending actions
   - Output: `{ primary_intent, tool_hint, explicit_request }`
   - Cost: ~$0.00009 per classification

2. **`/src/prompts/intent-classifier.js`** (NEW)
   - Classification rules (5 intent types)
   - Security guidelines (Phase 1 basic, Phase 2 advanced)

3. **Pending Actions State** (App.jsx)
   - Tracks confirmation flow
   - Example: "ChceÅ¡ PDF?" â†’ User confirms â†’ Tool Agent called

**Intent Types:**

| Intent | Description | Example | Tool Called? |
|--------|-------------|---------|--------------|
| query | User asks IF possible | "MÅ¯Å¾u dostat PDF?" | âŒ No (wait for confirm) |
| request | Direct command | "UdÄ›lej PDF" | âœ… Yes (immediate) |
| confirm | User confirms pending | "Ano" (after offer) | âœ… Yes |
| propose | Omnia offers tool | "ChceÅ¡ PDF?" | âŒ No (set pending) |
| chat | Normal conversation | "Jak se mÃ¡Å¡?" | âŒ No |

**Cost Analysis:**

```
OLD (keyword detection):
Main Model:  10,000 Ã— $0.005 = $50.00
Tool Agent:  10,000 Ã— $0.002 = $20.00  â† Runs ALWAYS!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL:                          $70.00/month

NEW (Intent Classifier):
Main Model:       10,000 Ã— $0.005   = $50.00  â† Unchanged
Intent Classifier: 10,000 Ã— $0.00009 = $0.90  â† ALWAYS (cheap!)
Tool Agent:        2,000 Ã— $0.002   = $4.00  â† 20% hit rate!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL:                             $54.90/month

ğŸ’° SAVINGS: $15.10/month (21.6% reduction!)
```

**Use cases unlocked:**

| Scenario | Old Behavior | New Behavior |
|----------|--------------|--------------|
| "MÅ¯Å¾u dostat PDF?" | Agent runs â†’ PDF | Omnia answers â†’ User confirms â†’ PDF |
| "hledej dokumentaci" | PDF triggered âŒ | Search results âœ… |
| "UdÄ›lej PDF" | Agent runs â†’ PDF | Agent runs â†’ PDF (correct!) |

**Success Metrics:**

- âœ… Intent accuracy >90%
- âœ… False positive rate <5%
- âœ… Latency <300ms
- âœ… Cost reduction >20%
- âœ… Confirmation flow works 100%

**Estimated time:** 10-14 hours (1.5-2 days)

**Dependencies:** Phase 1 (Background Agent) âœ… Already done!

**Documentation:** Complete guide at [/docs/INTENT_CLASSIFIER.md](./INTENT_CLASSIFIER.md)

---

### ğŸ“Š Phase 2: Chart Generation

**Goal:** Visualize data with charts/graphs

**Priority:** MEDIUM (useful but not critical)

**Technology:** QuickChart API (FREE, no auth!)

**What to build:**

1. **Add `generate_chart` tool to Gemini:**
   ```javascript
   {
     name: "generate_chart",
     description: "Generate chart from data",
     parameters: {
       type: {
         type: "string",
         enum: ["line", "bar", "pie", "doughnut", "radar", "scatter"]
       },
       data: {
         type: "object",
         properties: {
           labels: { type: "array" },
           datasets: { type: "array" }
         }
       },
       title: { type: "string" }
     }
   }
   ```

2. **Implement chart handler:**
   ```javascript
   async function handleGenerateChart(toolCall) {
     const { type, data, title } = toolCall.args;

     const chartConfig = {
       type: type,
       data: data,
       options: { title: { display: !!title, text: title } }
     };

     const encodedConfig = encodeURIComponent(JSON.stringify(chartConfig));
     const chartUrl = `https://quickchart.io/chart?c=${encodedConfig}`;

     return { type: 'image', url: chartUrl, alt: title };
   }
   ```

3. **Update Omnia prompt:**
   ```markdown
   **Chart Generation:**
   - Use when user wants to visualize data
   - Support types: line, bar, pie, doughnut, radar, scatter
   - Call immediately when user requests visualization
   ```

**Example usage:**

```
User: "Compare browser market share"

Omnia calls:
generate_chart({
  type: "pie",
  data: {
    labels: ["Chrome", "Safari", "Firefox", "Edge"],
    datasets: [{ data: [65, 20, 8, 7] }]
  },
  title: "Browser Market Share 2025"
})

Result: ğŸ¥§ Beautiful pie chart displayed!
```

**Benefits:**
- âœ… Visual data representation
- âœ… Better than text tables for some data
- âœ… Professional reports
- âœ… FREE (no API key needed!)

**Estimated time:** 1 day

**Dependencies:** Phase 1 (background agent) for parallel execution

---

### ğŸ¨ Phase 3: Artifacts System

**Goal:** Interactive code/apps/documents like Claude

**Priority:** MEDIUM-LOW (cool but not essential)

**Architecture:**

**Desktop (>768px):** Split view
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Header                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Chat Panel (60%)      â”‚ Artifact Panel (40%) â”‚
â”‚                       â”‚                       â”‚
â”‚ Messages...           â”‚ [Live Preview]       â”‚
â”‚                       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚                       â”‚  â”‚ Todo App        â”‚ â”‚
â”‚                       â”‚  â”‚ â€¢ Add task      â”‚ â”‚
â”‚                       â”‚  â”‚ â€¢ Task list     â”‚ â”‚
â”‚                       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ InputBar                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Mobile (<768px):** Full screen modal or bottom drawer
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Header           [Chat] [Preview] â† Tabs     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                               â”‚
â”‚ Chat view OR Preview view                    â”‚
â”‚ (user swipes/taps to switch)                 â”‚
â”‚                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**What to build:**

1. **Artifact detection:**
   ```javascript
   const artifactRegex = /<artifact\s+type="([^"]+)"\s+language="([^"]+)"\s+title="([^"]+)">([\s\S]*?)<\/artifact>/g;

   const artifacts = [];
   let match;
   while ((match = artifactRegex.exec(responseText)) !== null) {
     artifacts.push({
       type: match[1],
       language: match[2],
       title: match[3],
       content: match[4]
     });
   }
   ```

2. **Artifact panel component:**
   ```jsx
   <ArtifactPanel artifact={artifact}>
     {artifact.type === 'code' && (
       <CodePreview code={artifact.content} language={artifact.language} />
     )}
     {artifact.type === 'react' && (
       <ReactPreview code={artifact.content} />
     )}
   </ArtifactPanel>
   ```

3. **Update Omnia prompt:**
   ```markdown
   When creating code/apps/documents, wrap them in <artifact> tags:

   <artifact type="react" language="jsx" title="Todo App">
   import React, { useState } from 'react';
   // ... code here
   </artifact>
   ```

**Supported artifact types:**
- React components (live preview in iframe)
- Code snippets (Monaco editor with syntax highlighting)
- SVG diagrams
- Markdown documents

**Benefits:**
- âœ… Interactive previews
- âœ… "Claude-like" experience
- âœ… Better for teaching/learning
- âœ… Users can copy/download code

**Challenges:**
- âš ï¸ Complex UI changes (split view)
- âš ï¸ Mobile UX needs careful design
- âš ï¸ React preview needs sandboxing (iframe)

**Estimated time:** 5-7 days

**Dependencies:** None (standalone feature)

---

### ğŸ“ Phase 4: Mermaid Diagrams

**Goal:** Flowcharts, sequence diagrams, architecture diagrams

**Priority:** LOW (nice-to-have, not critical)

**Technology:** `rehype-mermaid` plugin

**What to build:**

1. **Install dependencies:**
   ```bash
   npm install rehype-mermaid mermaid
   ```

2. **Add to MessageRenderer:**
   ```javascript
   import rehypeMermaid from 'rehype-mermaid';

   <MDEditor.Markdown
     rehypePlugins={[rehypeKatex, rehypeMermaid]}
   />
   ```

3. **Update Omnia prompt:**
   ```markdown
   You can use Mermaid diagrams for flows and architecture:

   ```mermaid
   graph TD
       A[Start] --> B{Decision}
       B -->|Yes| C[Action]
       B -->|No| D[Other]
   ```
   ```

**Example output:**

```mermaid
sequenceDiagram
    User->>Frontend: Click login
    Frontend->>Backend: POST /auth
    Backend->>Database: Check credentials
    Database-->>Backend: User found
    Backend-->>Frontend: JWT token
    Frontend-->>User: Redirect
```

**Trade-offs:**
- âœ… Professional diagrams
- âœ… Better than text descriptions
- âŒ ~500KB bundle size increase
- âŒ Not all users need diagrams

**Estimated time:** 2-3 hours

**Dependencies:** None

---

## ğŸ”§ Technical Details

### Cost Analysis

**Model pricing comparison:**

| Model | Input (per 1M tokens) | Output (per 1M tokens) | Use Case |
|-------|----------------------|------------------------|----------|
| Flash 2.5 | $0.075 | $0.30 | Main conversation + search |
| Flash-Lite (2.5) | $0.0125 | $0.05 | Background agents (6x cheaper!) |
| Flash-Lite (2.0) | $0.075 | $0.30 | Intent Classifier (fast classification) |

**Why Flash-Lite for agents:**

Agent tasks are simple:
- âŒ Don't need deep reasoning
- âŒ Don't need complex context
- âœ… Just execute tool (chart, image, PDF)
- âœ… Follow simple instructions

**Result:** Same quality, 6x cheaper! ğŸ’°

**Why Gemini 2.0 Flash Lite for Intent Classifier:**

Classification tasks are ultra-lightweight:
- âœ… Small context window (10-15 messages)
- âœ… Simple JSON output (~100 tokens)
- âœ… Low temperature (0.3) for consistency
- âœ… Fast response (<300ms target)
- âœ… Cost: ~$0.00009 per classification

**Result:** 10,000 classifications/month = $0.90/month! Almost free! ğŸ’¸

### Parallel Execution Pattern

**Pattern we use (proven in summarization):**

```javascript
// DON'T await - start in background!
fetch('/api/background-agent', { ... })
  .then(res => res.json())
  .then(result => {
    // Update React state when done
    setMessages(prev => prev.map(msg =>
      msg.id === targetId
        ? { ...msg, agentResult: result }
        : msg
    ));
  })
  .catch(error => console.error(error));

console.log('Agent started in background, continuing...');

// Main model continues immediately (no blocking!)
const mainResponse = await geminiService.sendMessage(...);
```

**Key points:**
- âœ… No `await` on agent call
- âœ… Use `.then()` for non-blocking
- âœ… Update state when result arrives
- âœ… React handles concurrent state updates safely

### File Structure

```
/src
  /components
    /artifacts
      - ArtifactPanel.jsx       (future: Phase 3)
      - CodePreview.jsx         (future: Phase 3)
      - ReactPreview.jsx        (future: Phase 3)
  /services
    - backgroundAgent.js        (future: Phase 1)
    - chartService.js           (future: Phase 2)
  /prompts
    - omnia.js                  (updated with artifact instructions)
  /utils
    - contextBuilder.js         (parallel summarization logic)

/api
  - background-agent.js         (future: Phase 1)
  - summarize.js                (current: proof-of-concept)

/docs
  - ARCHITECTURE.md             (this file!)
```

---

## ğŸ’­ Lessons Learned

### 1. Google API Limitation Discovery

**Problem:** Couldn't use search + tools together
**Impact:** Blocked many advanced features
**Solution:** Background agent architecture
**Takeaway:** API limitations can inspire better architecture!

### 2. Parallel Execution is Safe

**Concern:** Race conditions with multiple Gemini calls
**Testing:** Parallel summarization (production logs)
**Result:** React state updates are atomic, no conflicts
**Takeaway:** Don't be afraid of parallel execution!

### 3. Cost Optimization Matters

**Discovery:** Flash-Lite is 6x cheaper than Flash 2.5
**Insight:** Agent tasks don't need expensive models
**Result:** Same quality, 6x lower cost
**Takeaway:** Right tool for the right job!

### 4. Proof-of-Concept First

**Approach:** Test parallel pattern with summarization first
**Benefit:** Validated architecture before big refactor
**Result:** Confident to build full agent system
**Takeaway:** Validate risky patterns with POCs!

### 5. User-Driven Features

**Input:** User asked "Can Omnia use tables like Claude?"
**Discovery:** MessageRenderer already supports it!
**Solution:** Just update prompt (15 lines)
**Takeaway:** Sometimes features exist, just need prompting!

---

## ğŸ“š References

- [Gemini API Documentation](https://ai.google.dev/docs)
- [QuickChart API](https://quickchart.io/)
- [Chart.js Documentation](https://www.chartjs.org/)
- [Mermaid Documentation](https://mermaid.js.org/)
- [React Markdown Editor](https://github.com/uiwjs/react-md-editor)

---

## ğŸ¯ Current Priority

**NEXT:** Implement Phase 1.5 (Intent Classifier) ğŸ§ 

**Why now:**
- âœ… Phase 1 (Background Agent) completed but runs for EVERY request (cost inefficient)
- âœ… Documentation complete ([/docs/INTENT_CLASSIFIER.md](./INTENT_CLASSIFIER.md))
- âœ… Solves false positives ("hledej dokumentaci" triggered PDF)
- âœ… $15/month savings (21% cost reduction)
- âœ… Better UX (confirmation flow for queries)

**Implementation steps:**
1. Create `/api/intent-classifier.js` endpoint (Gemini 2.0 Flash Lite)
2. Create `/src/prompts/intent-classifier.js` (classification rules)
3. Add `pendingActions` state to App.jsx
4. Update `handleSend` orchestration (parallel Main + Intent + conditional Tool)
5. Add pending detection in stream callback
6. Test all 10 scenarios
7. Deploy with gradual rollout

**Estimated time:** 10-14 hours (1.5-2 days)

**Success criteria:**
- âœ… Intent accuracy >90%
- âœ… False positive rate <5%
- âœ… Latency <300ms
- âœ… Cost reduction >20%

---

**Last updated:** 2025-01-16
**Author:** Cristian + Claude Code
**Status:** Phase 1 âœ… Done | Phase 1.5 ğŸ“ Documented, ready to implement! ğŸš€
