# ğŸ§  INTENT CLASSIFIER - AI Watcher for Tool Orchestration

**Date:** 2025-01-16
**Status:** Documentation complete, ready for implementation
**Branch:** `feature/intent-classifier-mvp`
**Priority:** ğŸš¨ HIGH - Cost optimization + UX improvement

---

## ğŸ“‹ TABLE OF CONTENTS

1. [Executive Summary](#-executive-summary)
2. [The Problem](#-the-problem)
3. [The Solution](#-the-solution)
4. [Core Architecture](#-core-architecture)
5. [Component Details](#-component-details)
6. [Intent Types](#-intent-types)
7. [Pending Actions System](#-pending-actions-system)
8. [Complete Flow Examples](#-complete-flow-examples)
9. [Cost Analysis](#-cost-analysis)
10. [Implementation Steps](#-implementation-steps)
11. [Testing Strategy](#-testing-strategy)
12. [Success Metrics](#-success-metrics)
13. [Deployment Plan](#-deployment-plan)
14. [Implementation Timeline](#%EF%B8%8F-implementation-timeline)
15. [Phase 2 Preview](#-phase-2-preview-future)
16. [Status Tracking](#-status-tracking)

---

## ğŸ¯ EXECUTIVE SUMMARY

**Intent Classifier** je autonomnÃ­ watcher agent bÄ›Å¾Ã­cÃ­ paralelnÄ› s Main Model. Analyzuje kaÅ¾dÃ½ user turn a rozhoduje kdy volat specialized tool agents. PouÅ¾Ã­vÃ¡ Gemini 2.0 Flash Lite pro ultra-levnou a rychlou klasifikaci.

### KlÃ­ÄovÃ½ princip:

```
Main Model VÅ½DY bÄ›Å¾Ã­ â†’ Konverzace + Search (ALWAYS)
Intent Classifier VÅ½DY sleduje â†’ AnalÃ½za zÃ¡mÄ›ru (ALWAYS)
Tool Agent bÄ›Å¾Ã­ PODMÃNÄšNÄš â†’ PDF/Image generation (ONLY when Intent says so)
```

### HlavnÃ­ pÅ™Ã­nosy:

| PÅ™Ã­nos | Popis |
|--------|-------|
| ğŸ’° **Cost Savings** | $15/mÄ›sÃ­c (21% reduction) - agent bÄ›Å¾Ã­ 2,000Ã— mÃ­sto 10,000Ã— |
| ğŸ¯ **Zero False Positives** | "hledej dokumentaci" uÅ¾ netriggeruje PDF |
| âœ… **Better UX** | "MÅ¯Å¾u dostat PDF?" â†’ Omnia vysvÄ›tlÃ­ â†’ User potvrdÃ­ â†’ PDF |
| âš¡ **Fast Classification** | <300ms latency, ~$0.00009 per classification |
| ğŸ”’ **Security Layer** | Phase 1: Basic intent detection, Phase 2: Advanced security |

---

## ğŸš¨ THE PROBLEM

### 1. Cost Control Issue

**Current behavior:**
```
KAÅ½DÃ user message â†’ Background Agent VÅ½DY bÄ›Å¾Ã­ â†’ 10,000 calls/mÄ›sÃ­c
```

**Problem:**
- Background agent bÄ›Å¾Ã­ i kdyÅ¾ nenÃ­ potÅ™eba
- 10,000Ã— mÄ›sÃ­ÄnÄ› Ã— $0.002 = **$20/mÄ›sÃ­c**
- 80% calls jsou zbyteÄnÃ© (user jen chatuje)

**Example:**
```
User: "Jak se mÃ¡Å¡?"
  â†“
Backend: SpustÃ­ agent (zbyteÄnÄ›!)
  â†“
Agent: "Å½Ã¡dnÃ½ tool nenÃ­ potÅ™eba"
  â†“
Cost: $0.002 (vyplÃ½tvÃ¡no!)
```

---

### 2. False Positive Tool Triggers

**PÅ¯vodnÃ­ problÃ©m s keyword detection:**

```javascript
// OLD CODE (odstranÄ›no v commit 28a85df):
const wantsDocument = /dokument|report|pdf|export/i.test(finalTextInput);

if (wantsDocument) {
  // âŒ PROBLÃ‰M: "hledej dokumentaci" obsahuje "dokument"!
  callAgent(); // FALSE POSITIVE!
}
```

**Real-world fail:**
```
User: "hledej dokumentaci pro React"
  â†“
Keyword match: "dokument" in "dokumentaci" â†’ PDF triggered!
  â†“
Result: PDF se generuje mÃ­sto search ğŸ˜±
```

**Why keyword detection doesn't work:**
- âŒ "dokumentaci" â‰  "dokument" (ale regex matchuje)
- âŒ "MÅ¯Å¾u dostat PDF?" â‰  "UdÄ›lej PDF" (oba matchujÃ­ "PDF")
- âŒ "diskutovat o PDF formÃ¡tu" nenÃ­ request (ale matchuje)
- âŒ Context chybÃ­ - keyword matching nemÅ¯Å¾e chÃ¡pat zÃ¡mÄ›r

---

### 3. Lack of Confirmation Flow

**User expectation:**
```
User: "MÅ¯Å¾u dostat PDF?"
Expected: Omnia vysvÄ›tlÃ­ moÅ¾nosti â†’ User potvrdÃ­ â†’ PDF generated
```

**Old behavior:**
```
User: "MÅ¯Å¾u dostat PDF?"
  â†“
Keyword match: "PDF" â†’ Agent IMMEDIATELY starts generating!
  â†“
Result: PDF se dÄ›lÃ¡ jeÅ¡tÄ› neÅ¾ Omnia odpovÄ›dÄ›la ğŸ˜±
```

**Problem:** UÅ¾ivatel se jen **ptal**, nepotvrdil akci!

---

## ğŸ’¡ THE SOLUTION

### High-Level Concept

Replace **keyword detection** with **AI-based intent understanding**.

```
OLD:
User message â†’ Keyword regex â†’ Tool Agent

NEW:
User message â†’ AI Intent Classifier â†’ RozhodnutÃ­ â†’ Tool Agent (conditionally)
```

### Key Innovations

1. **Gemini 2.0 Flash Lite** - Ultra-cheap model ($0.075/1M input) for classification
2. **Context-aware** - Analyzuje 10-15 recent messages, ne jen current message
3. **Pending Actions State** - Frontend tracks confirmation flow ("ChceÅ¡ PDF?" â†’ "Ano")
4. **Parallel Execution** - Main Model + Intent Classifier run simultaneously
5. **Autonomous Watcher** - Intent Classifier rozhoduje sÃ¡m, ne frontend

---

## ğŸ—ï¸ CORE ARCHITECTURE

### ParalelnÃ­ Orchestrace (3 komponenty)

```
KAÅ½DÃ USER TURN:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Main Model        â”‚  â”‚ Intent Classifier   â”‚  â”‚    Tool Agent       â”‚
â”‚   (Omnia)           â”‚  â”‚    (Watcher)        â”‚  â”‚  (Specialized)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… VÅ½DY bÄ›Å¾Ã­        â”‚  â”‚ âœ… VÅ½DY sleduje     â”‚  â”‚ âš ï¸ PODMÃNÄšNÄš        â”‚
â”‚                     â”‚  â”‚                     â”‚  â”‚                     â”‚
â”‚ â€¢ Konverzace        â”‚  â”‚ â€¢ AnalÃ½za zÃ¡mÄ›ru    â”‚  â”‚ â€¢ PDF generation    â”‚
â”‚ â€¢ Google Search     â”‚  â”‚ â€¢ Security checks   â”‚  â”‚ â€¢ Image generation  â”‚
â”‚ â€¢ Streaming odpovÄ›Ä â”‚  â”‚ â€¢ RozhodovÃ¡nÃ­       â”‚  â”‚ (jen kdyÅ¾ tÅ™eba)    â”‚
â”‚                     â”‚  â”‚ â€¢ Context analysis  â”‚  â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                        â”‚                        â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
                      Frontend kombinuje vÃ½sledky
```

### Execution Flow

```
User: "UdÄ›lej mi PDF z tÃ© konverzace"
  â”‚
  â”œâ”€â”€â†’ Main Model START (no await!)
  â”‚    â””â”€â†’ Stream: "PÅ™ipravuji PDF..."
  â”‚
  â”œâ”€â”€â†’ Intent Classifier START (parallel!)
  â”‚    â””â”€â†’ Analysis: {
  â”‚          primary_intent: "request",
  â”‚          tool_hint: "pdf_tool",
  â”‚          explicit_request: true
  â”‚        }
  â”‚        â†“
  â”‚    Decision: âœ… Call Tool Agent!
  â”‚        â†“
  â””â”€â”€â†’ Tool Agent START (conditional!)
       â””â”€â†’ Generate PDF
            â†“
       Both complete in parallel
            â†“
  Frontend: Omnia text + PDF link together! ğŸ‰
```

---

## ğŸ”§ COMPONENT DETAILS

### 1. Main Model (Omnia)

**File:** `/api/gemini.js`
**Status:** âœ… JiÅ¾ existuje, Å¾Ã¡dnÃ© zmÄ›ny!

**Role:**
- PrimÃ¡rnÃ­ konverzace s uÅ¾ivatelem
- Google Search grounding (factual info)
- Streaming text responses
- VÅ½DY bÄ›Å¾Ã­ pro kaÅ¾dÃ½ user message

**Model:** Gemini 2.5 Flash
**Cost:** ~$0.005 per user turn (unchanged)

**Key point:** Main Model zÅ¯stÃ¡vÃ¡ **nezmÄ›nÄ›n**. Intent Classifier je additional layer.

---

### 2. Intent Classifier (NEW!)

**File:** `/api/intent-classifier.js` (TO CREATE)
**Model:** Gemini 2.0 Flash Lite
**Cost:** $0.075/1M input tokens, $0.30/1M output tokens

**Input:**
```json
{
  "currentMessage": "UdÄ›lej mi PDF z toho",
  "recentContext": [
    { "sender": "user", "text": "..." },
    { "sender": "bot", "text": "..." },
    ...
  ],
  "pendingActions": {
    "pdf": false,
    "image": false
  }
}
```

**Output:**
```json
{
  "primary_intent": "request",
  "tool_hint": "pdf_tool",
  "explicit_request": true
}
```

**Role:**
1. Analyzuje KAÅ½DÃ user turn (parallel with Main Model)
2. Detekuje explicitnÃ­ requesty vs dotazy
3. Sleduje pending actions (confirmation flow support)
4. Rozhoduje KDY volat Tool Agent
5. Security layer (Phase 1: basic, Phase 2: advanced)

**Processing:**
```javascript
// 1. Build context (10-15 recent messages)
const contextText = recentContext.map(msg =>
  `${msg.sender}: ${msg.text}`
).join('\n');

// 2. Analyze with Flash Lite
const result = await model.generateContent({
  contents: [{
    role: 'user',
    parts: [{
      text: `Current message: "${currentMessage}"\n\n` +
            `Recent context:\n${contextText}\n\n` +
            `Pending actions: ${JSON.stringify(pendingActions)}\n\n` +
            `Analyze intent and return JSON.`
    }]
  }],
  generationConfig: {
    maxOutputTokens: 200,
    temperature: 0.3, // Low for consistent classification
    response_mime_type: 'application/json'
  }
});

// 3. Return structured intent
return JSON.parse(result.response.text());
```

**Context Window:**
- **10-15 messages** (start conservative, optimize later)
- ProÄ ne 3-5? â†’ Complex flows (image editing workflow) potÅ™ebujÃ­ vÃ­c kontextu
- ProÄ ne 20+? â†’ Unnecessary overhead pro simple requests

---

### 3. Tool Agent (Background Agent)

**File:** `/api/background-agent.js`
**Status:** âœ… JiÅ¾ existuje, Å¾Ã¡dnÃ© zmÄ›ny!

**Role:**
- PDF generation (markdown â†’ PDF)
- Image generation (Imagen 4)
- VolÃ¡n JEN kdyÅ¾ Intent Classifier Å™ekne
- ParalelnÃ­ execution s Main Model

**Model:** Gemini 2.5 Flash-Lite
**Cost:** ~$0.002 per call

**Key change:** VolÃ¡ se CONDITIONAL (20% hit rate) mÃ­sto ALWAYS (100%).

---

## ğŸ“Š INTENT TYPES

Intent Classifier rozpoznÃ¡vÃ¡ 5 typÅ¯ zÃ¡mÄ›rÅ¯:

### 1. "query" - User se ptÃ¡

**Definition:** User chce vÄ›dÄ›t **JE** moÅ¾nÃ© nÄ›co udÄ›lat.

**Examples:**
```
âœ… "MÅ¯Å¾u dostat PDF?"
âœ… "Can you make an image of that?"
âœ… "Je moÅ¾nÃ© exportovat tenhle chat?"
âœ… "UmÃ­Å¡ vygenerovat obrÃ¡zek?"
```

**Intent Classifier output:**
```json
{
  "primary_intent": "query",
  "tool_hint": "pdf_tool",
  "explicit_request": false  // âŒ NOT a request yet!
}
```

**Action:** âŒ Tool Agent NOT called. Omnia odpovÃ­dÃ¡, user musÃ­ potvrdit.

---

### 2. "request" - ExplicitnÃ­ pÅ™Ã­kaz

**Definition:** User pÅ™Ã­mo Å¾Ã¡dÃ¡ o akci, **bez** pÅ™edchozÃ­ho dotazu.

**Examples:**
```
âœ… "UdÄ›lej PDF"
âœ… "Generate an image of a sunset"
âœ… "Create a report from this conversation"
âœ… "Vygeneruj logo pro nail salon"
```

**Intent Classifier output:**
```json
{
  "primary_intent": "request",
  "tool_hint": "pdf_tool",
  "explicit_request": true  // âœ… Direct request!
}
```

**Action:** âœ… Tool Agent called IMMEDIATELY (parallel with Main Model).

---

### 3. "confirm" - PotvrzenÃ­ pending action

**Definition:** User potvrzuje dÅ™Ã­ve nabÃ­dnutou akci (after Omnia offered).

**Examples:**
```
Context: Omnia asked "ChceÅ¡ PDF?" (pendingActions.pdf = true)

User responses:
âœ… "Ano"
âœ… "Yes please"
âœ… "Ok, do it"
âœ… "JasnÄ›"
âœ… "Sure"
```

**Intent Classifier output:**
```json
{
  "primary_intent": "confirm",
  "tool_hint": "pdf_tool",
  "explicit_request": true  // âœ… Confirmation = explicit!
}
```

**Action:** âœ… Tool Agent called (user confirmed pending action).

**Critical rule:** Intent Classifier checks `pendingActions` state:
```javascript
if (userSaysYes && pendingActions.pdf === true) {
  return { primary_intent: "confirm", explicit_request: true };
}
```

---

### 4. "propose" - Omnia nabÃ­zÃ­

**Definition:** **Omnia** (ne user!) nabÃ­zÃ­ tool v odpovÄ›di.

**Examples:**
```
Omnia: "ChceÅ¡ abych to udÄ›lala jako PDF?"
Omnia: "Would you like me to generate an image?"
Omnia: "MÃ¡m ti vytvoÅ™it report?"
```

**Intent Classifier output:**
```json
{
  "primary_intent": "propose",
  "tool_hint": "pdf_tool",
  "explicit_request": false
}
```

**Action:**
1. âŒ Tool Agent NOT called yet
2. âœ… Frontend sets `pendingActions.pdf = true`
3. Waits for user confirmation

**Note:** "propose" se detekuje v **Omnia's stream** (frontend), ne Intent Classifier!

---

### 5. "chat" - NormÃ¡lnÃ­ konverzace

**Definition:** Å½Ã¡dnÃ½ tool nenÃ­ potÅ™eba, jen normÃ¡lnÃ­ chat.

**Examples:**
```
âœ… "Jak se mÃ¡Å¡?"
âœ… "Thanks!"
âœ… "Tell me about React"
âœ… "Co je to PDF formÃ¡t?" (diskuze, ne request!)
âœ… "hledej dokumentaci" (search, ne tool!)
```

**Intent Classifier output:**
```json
{
  "primary_intent": "chat",
  "tool_hint": null,
  "explicit_request": false
}
```

**Action:** âŒ Tool Agent NOT called. Jen Main Model odpovÃ­dÃ¡.

---

### Intent Decision Matrix

| User Message | Intent Type | Tool Hint | Explicit Request | Tool Called? | Pending Set? |
|--------------|-------------|-----------|------------------|--------------|--------------|
| "MÅ¯Å¾u dostat PDF?" | query | pdf_tool | false | âŒ No | âœ… Yes (pdf) |
| "UdÄ›lej PDF" | request | pdf_tool | true | âœ… Yes | âŒ No |
| "Ano" (after offer) | confirm | pdf_tool | true | âœ… Yes | âŒ Clear pending |
| "Jak se mÃ¡Å¡?" | chat | null | false | âŒ No | âŒ No |
| "hledej dokumentaci" | chat | null | false | âŒ No | âŒ No |
| "Vygeneruj obrÃ¡zek" | request | image_tool | true | âœ… Yes | âŒ No |

---

## ğŸ”„ PENDING ACTIONS SYSTEM

### State Management

**Frontend state:**
```javascript
const [pendingActions, setPendingActions] = useState({
  pdf: false,
  image: false
});
```

### Confirmation Flow (Complete)

#### Step 1: User Query
```
User: "MÅ¯Å¾u dostat PDF?"
  â†“
Intent Classifier: {
  primary_intent: "query",
  tool_hint: "pdf_tool",
  explicit_request: false
}
  â†“
Action: âŒ Tool Agent NOT called
        âœ… Main Model answers
```

#### Step 2: Omnia Proposes
```
Omnia streams: "Ano, mohu pÅ™ipravit PDF. ChceÅ¡?"
  â†“
Frontend detects "ChceÅ¡" + "PDF" in stream
  â†“
setPendingActions({ ...prev, pdf: true })
  â†“
State: pendingActions.pdf = true
```

#### Step 3: User Confirms
```
User: "Ano, prosÃ­m"
  â†“
Intent Classifier receives:
{
  currentMessage: "Ano, prosÃ­m",
  recentContext: [...],
  pendingActions: { pdf: true, image: false }  // âœ… PDF is pending!
}
  â†“
Intent Classifier: {
  primary_intent: "confirm",
  tool_hint: "pdf_tool",
  explicit_request: true  // âœ… User confirmed pending action
}
  â†“
Action: âœ… Tool Agent called
        âœ… setPendingActions({ ...prev, pdf: false })
```

### Detection Logic (Frontend)

**In handleStreamUpdate callback:**
```javascript
// Detect when Omnia offers tools
if (chunk.includes('ChceÅ¡') && (chunk.includes('PDF') || chunk.includes('pdf'))) {
  setPendingActions(prev => ({ ...prev, pdf: true }));
  console.log('ğŸ“Œ [PENDING] PDF action pending (user needs to confirm)');
}

if (chunk.includes('ChceÅ¡') && (chunk.includes('obrÃ¡zek') || chunk.includes('image'))) {
  setPendingActions(prev => ({ ...prev, image: true }));
  console.log('ğŸ“Œ [PENDING] Image action pending');
}
```

### Edge Cases

**1. User rejects:**
```
User: "MÅ¯Å¾u dostat PDF?"
Omnia: "Ano, chceÅ¡?"
User: "Ne, dÃ­ky"
  â†“
Intent: { primary_intent: "chat", explicit_request: false }
  â†“
Action: Clear pending â†’ setPendingActions({ ...prev, pdf: false })
```

**2. User changes topic:**
```
pendingActions: { pdf: true }
User: "Jak se dÄ›lÃ¡ pavlova?"
  â†“
Intent: { primary_intent: "chat" }
  â†“
Action: Clear ALL pending (user moved on)
```

**3. Multiple pending:**
```
pendingActions: { pdf: true, image: true }
User: "Ano" (without context)
  â†“
Intent Classifier: Detects BOTH pending
  â†“
Resolution: Ask user which one (or pick most recent offer)
```

---

## ğŸ”„ COMPLETE FLOW EXAMPLES

### Example 1: Query â†’ Confirm (Confirmation Flow)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER TURN 1: "MÅ¯Å¾u dostat ten report jako PDF?"                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â”œâ”€â”€â†’ Main Model (Omnia)         â”œâ”€â”€â†’ Intent Classifier
  â”‚    Model: Gemini 2.5 Flash    â”‚    Model: Flash Lite
  â”‚    RUNNING...                  â”‚    ANALYZING...
  â”‚    â†“                           â”‚    â†“
  â”‚    Streams:                    â”‚    Returns:
  â”‚    "Ano, mohu pÅ™ipravit PDF    â”‚    {
  â”‚    z tÃ©to konverzace.          â”‚      "primary_intent": "query",
  â”‚    ChceÅ¡?"                     â”‚      "tool_hint": "pdf_tool",
  â”‚                                â”‚      "explicit_request": false
  â”‚                                â”‚    }
  â”‚                                â”‚    â†“
  â”‚                                â”‚    Decision: âŒ NOT a request yet
  â”‚                                â”‚              User just ASKED
  â”‚                                â”‚
  â”‚    Frontend detects "ChceÅ¡" + "PDF"
  â”‚    â†“
  â”‚    setPendingActions({ pdf: true })
  â”‚    â†“
  â””â”€â”€â†’ State: pendingActions.pdf = true
       Tool Agent: âŒ NOT called
       User sees: "Ano, mohu pÅ™ipravit PDF z tÃ©to konverzace. ChceÅ¡?"

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER TURN 2: "Ano, prosÃ­m"                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â”œâ”€â”€â†’ Main Model (Omnia)         â”œâ”€â”€â†’ Intent Classifier
  â”‚    RUNNING...                  â”‚    Input:
  â”‚    â†“                           â”‚    {
  â”‚    Streams:                    â”‚      currentMessage: "Ano, prosÃ­m",
  â”‚    "PÅ™ipravuji PDF..."         â”‚      recentContext: [
  â”‚                                â”‚        { sender: "user", text: "MÅ¯Å¾u dostat PDF?" },
  â”‚                                â”‚        { sender: "bot", text: "Ano, mohu... ChceÅ¡?" },
  â”‚                                â”‚        { sender: "user", text: "Ano, prosÃ­m" }
  â”‚                                â”‚      ],
  â”‚                                â”‚      pendingActions: { pdf: true }
  â”‚                                â”‚    }
  â”‚                                â”‚    â†“
  â”‚                                â”‚    ANALYZING...
  â”‚                                â”‚    â†“
  â”‚                                â”‚    Returns:
  â”‚                                â”‚    {
  â”‚                                â”‚      "primary_intent": "confirm",
  â”‚                                â”‚      "tool_hint": "pdf_tool",
  â”‚                                â”‚      "explicit_request": true
  â”‚                                â”‚    }
  â”‚                                â”‚    â†“
  â”‚                                â”‚    Decision: âœ… User confirmed!
  â”‚                                â”‚              pending.pdf = true
  â”‚                                â”‚              â†’ Call Tool Agent
  â”‚                                â”‚    â†“
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                  â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚  Tool Agent    â”‚
                          â”‚  (Background)  â”‚
                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                          â”‚ GENERATING PDF â”‚
                          â”‚ â†“              â”‚
                          â”‚ PDF created    â”‚
                          â”‚ â†“              â”‚
                          â”‚ Returns:       â”‚
                          â”‚ {              â”‚
                          â”‚   title: "...",â”‚
                          â”‚   base64: "...",
                          â”‚   filename: "report.pdf"
                          â”‚ }              â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚ Frontend Updates           â”‚
                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                          â”‚ 1. Clear pending:          â”‚
                          â”‚    pendingActions.pdf=falseâ”‚
                          â”‚ 2. Add PDF to message:     â”‚
                          â”‚    msg.pdfData = {...}     â”‚
                          â”‚ 3. Show download link      â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RESULT:
âœ… Omnia text: "PÅ™ipravuji PDF..."
âœ… PDF link: ğŸ“„ "Download report.pdf"
âœ… User happy: Got explanation THEN PDF (not immediate surprise!)
```

---

### Example 2: Explicit Request (No Confirmation Needed)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER: "UdÄ›lej mi PDF z tÃ© konverzace"                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â”œâ”€â”€â†’ Main Model (Omnia)         â”œâ”€â”€â†’ Intent Classifier
  â”‚    RUNNING...                  â”‚    ANALYZING...
  â”‚    â†“                           â”‚    â†“
  â”‚    Streams:                    â”‚    Returns:
  â”‚    "PÅ™ipravuji PDF             â”‚    {
  â”‚    z konverzace..."            â”‚      "primary_intent": "request",
  â”‚                                â”‚      "tool_hint": "pdf_tool",
  â”‚                                â”‚      "explicit_request": true
  â”‚                                â”‚    }
  â”‚                                â”‚    â†“
  â”‚                                â”‚    Decision: âœ… Direct request!
  â”‚                                â”‚              â†’ Call Tool Agent IMMEDIATELY
  â”‚                                â”‚    â†“
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                  â”‚
                     ALL 3 RUN IN PARALLEL! ğŸš€
                                  â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                       â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Main Model â”‚         â”‚   Intent     â”‚      â”‚  Tool Agent    â”‚
    â”‚ (Streams)  â”‚         â”‚ (Decides)    â”‚      â”‚ (Generates)    â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                       â”‚                      â”‚
          â”‚ "PÅ™ipravuji..."       â”‚ explicit_request:    â”‚ PDF building...
          â”‚                       â”‚ true                 â”‚
          â”‚                       â”‚                      â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚          Frontend combines results                           â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ 1. Show Omnia text immediately (streaming)                   â”‚
    â”‚ 2. Show "Generating PDF..." shimmer                          â”‚
    â”‚ 3. When PDF ready, add download link                         â”‚
    â”‚ 4. User sees BOTH together! âœ¨                               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RESULT:
âœ… Fast response (parallel execution)
âœ… No confusion (user explicitly requested)
âœ… Omnia text + PDF appear together
```

---

### Example 3: Normal Chat (No Tools Needed)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER: "Jak se mÃ¡Å¡?"                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â”œâ”€â”€â†’ Main Model (Omnia)         â”œâ”€â”€â†’ Intent Classifier
  â”‚    RUNNING...                  â”‚    ANALYZING...
  â”‚    â†“                           â”‚    â†“
  â”‚    Streams:                    â”‚    Returns:
  â”‚    "MÃ¡m se skvÄ›le! A ty?"      â”‚    {
  â”‚                                â”‚      "primary_intent": "chat",
  â”‚                                â”‚      "tool_hint": null,
  â”‚                                â”‚      "explicit_request": false
  â”‚                                â”‚    }
  â”‚                                â”‚    â†“
  â”‚                                â”‚    Decision: âŒ Just chat
  â”‚                                â”‚              â†’ NO Tool Agent
  â”‚                                â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Tool Agent: âŒ NOT called (saving $0.002! ğŸ’°)

RESULT:
âœ… Fast response (only Main Model)
âœ… Low cost (no unnecessary agent)
âœ… Intent Classifier cost: $0.00009 (almost free!)
```

---

### Example 4: False Positive Prevention

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER: "hledej dokumentaci pro React hooks"                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OLD BEHAVIOR (keyword detection):
  â†“
  Regex match: /dokument/i.test("dokumentaci") â†’ TRUE âŒ
  â†“
  Agent called â†’ PDF generation starts! ğŸ˜±
  â†“
  User confused: "I just wanted search results..."

NEW BEHAVIOR (Intent Classifier):
  â”‚
  â”œâ”€â”€â†’ Main Model                 â”œâ”€â”€â†’ Intent Classifier
  â”‚    RUNNING with Search        â”‚    ANALYZING...
  â”‚    â†“                           â”‚    â†“
  â”‚    Searches Google             â”‚    Context: "hledej dokumentaci"
  â”‚    Returns React docs          â”‚    â†“
  â”‚                                â”‚    Returns:
  â”‚                                â”‚    {
  â”‚                                â”‚      "primary_intent": "chat",
  â”‚                                â”‚      "tool_hint": null,
  â”‚                                â”‚      "explicit_request": false
  â”‚                                â”‚    }
  â”‚                                â”‚    â†“
  â”‚                                â”‚    Reasoning:
  â”‚                                â”‚    - "hledej" = search intent
  â”‚                                â”‚    - "dokumentaci" = info needed
  â”‚                                â”‚    - NO PDF request
  â”‚                                â”‚    â†“
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â†’ Decision: âŒ NO Tool Agent

Tool Agent: âŒ NOT called (correct!)

RESULT:
âœ… Search results returned (as expected)
âœ… No PDF generated (correct behavior)
âœ… Zero false positive!
```

---

## ğŸ’° COST ANALYSIS

### Per User Turn Breakdown

**Intent Classifier:**
```
Input:
- Current message: ~30 tokens
- 15 recent messages Ã— 50 tokens avg = 750 tokens
- Pending actions JSON: ~20 tokens
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total input: ~800 tokens

Cost: 800 Ã— $0.000000075 = $0.00006

Output:
- JSON response: ~100 tokens
Cost: 100 Ã— $0.0000003 = $0.00003
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total per classification: ~$0.00009
```

**Tool Agent (when called):**
```
Flash-Lite execution: ~$0.002 per call
(Includes prompt, tool execution, response)
```

**Main Model (unchanged):**
```
Flash 2.5 conversation: ~$0.005 per turn
(Includes context, search, streaming)
```

---

### Monthly Cost Comparison

**Assumptions:**
- 10,000 user turns per month
- OLD: Agent runs 100% (10,000 calls)
- NEW: Agent runs 20% (2,000 calls) - Intent Classifier filters 80%

#### OLD SYSTEM (Keyword Detection)
```
Main Model:     10,000 Ã— $0.005 = $50.00
Tool Agent:     10,000 Ã— $0.002 = $20.00  â† Runs ALWAYS!
Intent Classifier:                 $0.00  â† Doesn't exist
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL:                            $70.00/month
```

#### NEW SYSTEM (Intent Classifier)
```
Main Model:     10,000 Ã— $0.005 = $50.00  â† Unchanged
Intent Classifier: 10,000 Ã— $0.00009 = $0.90  â† ALWAYS runs (cheap!)
Tool Agent:      2,000 Ã— $0.002 = $4.00  â† 20% hit rate only!
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOTAL:                            $54.90/month

ğŸ’° SAVINGS: $15.10/month (21.6% reduction!)
```

---

### Cost per Scenario

| Scenario | Main Model | Intent Classifier | Tool Agent | Total | OLD Total | Savings |
|----------|------------|-------------------|------------|-------|-----------|---------|
| Normal chat | $0.005 | $0.00009 | $0.00 | **$0.00509** | $0.007 | $0.00191 |
| Query â†’ Confirm | $0.010 | $0.00018 | $0.002 | **$0.01218** | $0.016 | $0.00382 |
| Explicit request | $0.005 | $0.00009 | $0.002 | **$0.00709** | $0.007 | -$0.00009 |
| False positive avoided | $0.005 | $0.00009 | $0.00 | **$0.00509** | $0.007 | $0.00191 |

**Key insight:** Intent Classifier adds ~$0.00009 overhead but saves $0.002 on 80% of requests!

---

### ROI Calculation

**Development time:** 10-14 hours
**Developer cost:** ~$500-700 (at $50/hour)
**Monthly savings:** $15.10

**ROI:**
```
Break-even: $600 Ã· $15.10/month = 40 months

BUT:
+ Zero false positives = Better UX = Happier users = Priceless! âœ¨
+ Foundation for Phase 2 (security) = Prevents future issues
+ Scalable = More users = More savings
```

**At 100,000 user turns/month:**
```
Savings: $151/month
ROI: 4 months! ğŸš€
```

---

## ğŸ“ IMPLEMENTATION STEPS

### Step 1: Create Intent Classifier Endpoint

**File:** `/api/intent-classifier.js` (NEW)
**Estimated time:** 2-3 hours
**Priority:** P0 (blocking)

```javascript
// api/intent-classifier.js
import { VertexAI } from '@google-cloud/vertexai';
import { INTENT_CLASSIFIER_PROMPT } from '../src/prompts/intent-classifier.js';

export default async function handler(req, res) {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') return res.status(200).end();
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { currentMessage, recentContext, pendingActions } = req.body;

    console.log('ğŸ§  [INTENT] Classification request:', {
      message: currentMessage?.substring(0, 50),
      contextLength: recentContext?.length || 0,
      pending: pendingActions,
      timestamp: new Date().toISOString()
    });

    // Validate input
    if (!currentMessage || !Array.isArray(recentContext)) {
      return res.status(400).json({
        error: 'Invalid input: currentMessage and recentContext required'
      });
    }

    // Check for required credentials
    if (!process.env.GOOGLE_CLOUD_PROJECT_ID ||
        !process.env.GOOGLE_APPLICATION_CREDENTIALS) {
      return res.status(500).json({
        error: 'Google Cloud credentials missing'
      });
    }

    // Parse credentials
    const credentials = JSON.parse(process.env.GOOGLE_APPLICATION_CREDENTIALS);

    // Initialize Vertex AI
    const vertexAI = new VertexAI({
      project: process.env.GOOGLE_CLOUD_PROJECT_ID,
      location: 'us-central1',
      googleAuthOptions: {
        credentials: credentials,
        scopes: ['https://www.googleapis.com/auth/cloud-platform']
      }
    });

    console.log('âœ… [INTENT] Vertex AI initialized');

    // Initialize Gemini 2.0 Flash Lite model
    const model = vertexAI.getGenerativeModel({
      model: 'gemini-2.0-flash-lite',
      systemInstruction: INTENT_CLASSIFIER_PROMPT,
      generationConfig: {
        maxOutputTokens: 200,
        temperature: 0.3, // Low for consistent classification
        topP: 0.95,
        topK: 30,
        responseMimeType: 'application/json' // Force JSON output
      }
    });

    console.log('ğŸ¤– [INTENT] Model initialized (Gemini 2.0 Flash Lite)');

    // Build context text from recent messages
    const contextText = recentContext
      .map(msg => `${msg.sender === 'user' ? 'User' : 'Omnia'}: ${msg.text || msg.content || ''}`)
      .join('\n');

    // Build analysis prompt
    const analysisPrompt = `Current message: "${currentMessage}"

Recent context:
${contextText}

Pending actions: ${JSON.stringify(pendingActions || {})}

Analyze the user's intent and return JSON with:
- primary_intent: query|request|confirm|propose|chat
- tool_hint: pdf_tool|image_tool|null
- explicit_request: true|false`;

    console.log('ğŸ“¤ [INTENT] Sending to Flash Lite:', {
      promptLength: analysisPrompt.length,
      contextLines: recentContext.length
    });

    // Call model
    const result = await model.generateContent({
      contents: [{
        role: 'user',
        parts: [{ text: analysisPrompt }]
      }]
    });

    const responseText = result.response.text();
    console.log('ğŸ“¥ [INTENT] Raw response:', responseText.substring(0, 200));

    // Parse JSON response
    const intent = JSON.parse(responseText);

    // Validate output structure
    if (!intent.primary_intent || intent.tool_hint === undefined ||
        intent.explicit_request === undefined) {
      throw new Error('Invalid intent structure from model');
    }

    console.log('âœ… [INTENT] Classification complete:', intent);

    return res.json(intent);

  } catch (error) {
    console.error('ğŸ’¥ [INTENT] Error:', error);

    return res.status(500).json({
      error: error.message || 'Intent classification failed',
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
}
```

---

### Step 2: Create Intent Classifier Prompt

**File:** `/src/prompts/intent-classifier.js` (NEW)
**Estimated time:** 1-2 hours
**Priority:** P0 (blocking)

```javascript
// src/prompts/intent-classifier.js

export const INTENT_CLASSIFIER_PROMPT = `You are Intent Classifier for Omnia AI.

Your role: Analyze user messages and determine their intent regarding tool usage (PDF generation, image generation).

## PRIMARY_INTENT Types:

1. **"query"** - User asks IF they can do something
   Examples:
   - "MÅ¯Å¾u dostat PDF?"
   - "Can you make an image?"
   - "Je moÅ¾nÃ© exportovat tenhle chat?"

2. **"request"** - User explicitly requests action
   Examples:
   - "UdÄ›lej PDF"
   - "Generate an image of a sunset"
   - "Create a report"
   - "Vygeneruj logo"

3. **"confirm"** - User confirms pending action
   Examples (after Omnia offered):
   - "Ano"
   - "Yes please"
   - "Ok, do it"
   - "JasnÄ›"
   - "Sure"

4. **"propose"** - Omnia offers to do something
   Examples:
   - When Omnia says "ChceÅ¡ PDF?"
   - When Omnia asks "Would you like me to generate an image?"

5. **"chat"** - Normal conversation, no tools needed
   Examples:
   - "Jak se mÃ¡Å¡?"
   - "Thanks!"
   - "Tell me about React"
   - "hledej dokumentaci" (search intent, NOT document creation!)

## TOOL_HINT:

Determine which tool (if any) is relevant:

- **"pdf_tool"** - PDF generation, export, document creation
  Keywords: PDF, report, export, dokument (as creation, NOT search!)

- **"image_tool"** - Image generation, editing, visual content
  Keywords: image, obrÃ¡zek, picture, logo, vizualizace, vygeneruj

- **null** - No tool needed (normal chat, search, questions)

## EXPLICIT_REQUEST:

Determine if this is an explicit request for action:

- **true** - User is directly requesting OR confirming a pending action
  - Direct command: "UdÄ›lej PDF"
  - Confirmation with pending action: "Ano" (when pendingActions.pdf = true)

- **false** - User is just asking, chatting, or discussing
  - Query: "MÅ¯Å¾u dostat PDF?"
  - Chat: "Jak se mÃ¡Å¡?"
  - Discussion: "Co je to PDF formÃ¡t?"

## CRITICAL RULES:

1. **Context matters!**
   - "MÅ¯Å¾u dostat PDF?" = query (NOT request!)
   - "UdÄ›lej PDF" = request
   - "hledej dokumentaci" = chat (search intent, keyword "dokument" does NOT mean PDF creation!)

2. **Check pendingActions!**
   - If user says "Ano" AND pendingActions.pdf = true â†’ explicit_request = true (confirm)
   - If user says "Ano" BUT pendingActions empty â†’ explicit_request = false (just chat)

3. **Full conversation context!**
   - Don't just look at current message
   - Consider what Omnia said before
   - Check if Omnia offered something (pendingActions)

4. **Search vs Creation!**
   - "hledej dokumentaci" = search (tool_hint: null)
   - "vytvoÅ™ dokument" = creation (tool_hint: "pdf_tool")

5. **Questions vs Commands!**
   - "Can I..." / "MÅ¯Å¾u..." = query
   - "Create..." / "UdÄ›lej..." = request

## OUTPUT FORMAT:

Return ONLY valid JSON, no other text:

{
  "primary_intent": "query|request|confirm|propose|chat",
  "tool_hint": "pdf_tool|image_tool|null",
  "explicit_request": true|false
}

## EXAMPLES:

Input: "MÅ¯Å¾u dostat PDF?"
Output: {"primary_intent":"query","tool_hint":"pdf_tool","explicit_request":false}

Input: "UdÄ›lej PDF"
Output: {"primary_intent":"request","tool_hint":"pdf_tool","explicit_request":true}

Input: "Ano" (with pendingActions.pdf=true)
Output: {"primary_intent":"confirm","tool_hint":"pdf_tool","explicit_request":true}

Input: "Jak se mÃ¡Å¡?"
Output: {"primary_intent":"chat","tool_hint":null,"explicit_request":false}

Input: "hledej dokumentaci pro React"
Output: {"primary_intent":"chat","tool_hint":null,"explicit_request":false}

Input: "Vygeneruj obrÃ¡zek moÅ™e"
Output: {"primary_intent":"request","tool_hint":"image_tool","explicit_request":true}

Be consistent, accurate, and always return valid JSON.`;
```

---

### Step 3: Add Pending Actions State

**File:** `/src/App.jsx` (MODIFY)
**Location:** After existing state declarations (around line 50)
**Estimated time:** 0.5 hours
**Priority:** P0

```javascript
// Add new state for tracking pending actions
const [pendingActions, setPendingActions] = useState({
  pdf: false,
  image: false
});
```

---

### Step 4: Update handleSend Orchestration

**File:** `/src/App.jsx` (MODIFY)
**Location:** handleSend function (around line 1700)
**Action:** REMOVE lines 1810-1923 (old auto-agent code), ADD new orchestration
**Estimated time:** 2-3 hours
**Priority:** P0

```javascript
// In handleSend function, after contextForGemini is prepared

// ==========================================
// NEW ORCHESTRATION: 3-Component Parallel System
// ==========================================

// 1ï¸âƒ£ VÅ½DY spustit Main Model (no await - runs in parallel!)
console.log('ğŸš€ [ORCHESTRATION] Starting Main Model (Omnia)...');

const omniaPromise = geminiService.sendMessage(
  contextForGemini,
  handleStreamUpdate, // Streaming callback
  null, // search callback (not used)
  (images) => {
    // Image callback (if Main Model generates images)
    setMessages(prev =>
      prev.map(msg =>
        msg.id === botMessageId
          ? { ...msg, shimmerText: null, images: images }
          : msg
      )
    );
  },
  (pdfData) => {
    // PDF callback (if Main Model generates PDF)
    setMessages(prev =>
      prev.map(msg =>
        msg.id === botMessageId
          ? { ...msg, shimmerText: null, pdfData: pdfData }
          : msg
      )
    );
  },
  documentsToPassToGemini,
  false, // imageMode (not using keywords anymore)
  false  // pdfMode (not using keywords anymore)
);

// 2ï¸âƒ£ VÅ½DY spustit Intent Classifier (parallel analysis!)
console.log('ğŸ§  [ORCHESTRATION] Starting Intent Classifier...');

const recentContext = messagesWithUser.slice(-15); // Last 15 messages for context

try {
  const intentResponse = await fetch('/api/intent-classifier', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      currentMessage: finalTextInput,
      recentContext: recentContext.map(msg => ({
        sender: msg.sender,
        text: msg.text || msg.content || ''
      })),
      pendingActions: pendingActions
    })
  });

  if (!intentResponse.ok) {
    throw new Error(`Intent classification failed: ${intentResponse.status}`);
  }

  const intent = await intentResponse.json();

  console.log('ğŸ§  [INTENT] Classification result:', {
    primary_intent: intent.primary_intent,
    tool_hint: intent.tool_hint,
    explicit_request: intent.explicit_request
  });

  // 3ï¸âƒ£ PODMÃNÄšNÄš spustit Tool Agent (only if Intent says so!)
  if (intent.explicit_request && intent.tool_hint) {
    console.log('ğŸ”§ [TOOL] Intent approved tool call:', intent.tool_hint);

    // Call background agent with tool hint
    fetch('/api/background-agent', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        task: finalTextInput,
        context: recentContext.slice(-5).map(msg => ({
          sender: msg.sender,
          text: msg.text || msg.content || ''
        })),
        toolType: intent.tool_hint === 'pdf_tool' ? 'pdf' : 'image'
      })
    })
    .then(res => {
      if (!res.ok) {
        throw new Error(`Tool Agent failed: ${res.status}`);
      }
      return res.json();
    })
    .then(agentResult => {
      if (agentResult.success) {
        console.log('âœ… [TOOL] Agent completed:', agentResult.toolType);

        // Handle PDF result
        if (agentResult.toolType === 'pdf' && agentResult.result) {
          setMessages(prev =>
            prev.map(msg =>
              msg.id === botMessageId
                ? {
                    ...msg,
                    shimmerText: null,
                    pdfData: {
                      title: agentResult.result.title,
                      base64: agentResult.result.base64,
                      filename: agentResult.result.filename
                    }
                  }
                : msg
            )
          );
        }

        // Handle Image result
        if (agentResult.toolType === 'image' && agentResult.result?.images) {
          setMessages(prev =>
            prev.map(msg =>
              msg.id === botMessageId
                ? {
                    ...msg,
                    shimmerText: null,
                    images: agentResult.result.images
                  }
                : msg
            )
          );
        }
      } else {
        console.error('âŒ [TOOL] Agent returned error:', agentResult.error);
      }
    })
    .catch(error => {
      console.error('ğŸ’¥ [TOOL] Agent error:', error);
    });

    // Clear pending action
    setPendingActions(prev => ({
      ...prev,
      [intent.tool_hint === 'pdf_tool' ? 'pdf' : 'image']: false
    }));

  } else {
    console.log('â­ï¸ [TOOL] No tool needed:', {
      explicit_request: intent.explicit_request,
      tool_hint: intent.tool_hint
    });
  }

} catch (error) {
  console.error('ğŸ’¥ [INTENT] Classification error:', error);
  // Fail gracefully - Main Model continues working
}

// Main Model continues (already started above with omniaPromise)
```

---

### Step 5: Add Pending Detection in Stream

**File:** `/src/App.jsx` (MODIFY)
**Location:** handleStreamUpdate callback (around line 1824)
**Estimated time:** 1 hour
**Priority:** P1

```javascript
// In handleStreamUpdate callback
// Add after existing chunk processing logic

const handleStreamUpdate = (chunk, isStreamingParam, extra = {}) => {
  // ... existing code ...

  // Detect when Omnia offers tools in her response
  if (chunk) {
    // Detect PDF offer
    if ((chunk.includes('ChceÅ¡') || chunk.includes('chceÅ¡')) &&
        (chunk.includes('PDF') || chunk.includes('pdf'))) {
      console.log('ğŸ“Œ [PENDING] PDF action pending (Omnia offered)');
      setPendingActions(prev => ({ ...prev, pdf: true }));
    }

    // Detect image offer
    if ((chunk.includes('ChceÅ¡') || chunk.includes('chceÅ¡')) &&
        (chunk.includes('obrÃ¡zek') || chunk.includes('image') ||
         chunk.includes('generovat') || chunk.includes('vizualizaci'))) {
      console.log('ğŸ“Œ [PENDING] Image action pending (Omnia offered)');
      setPendingActions(prev => ({ ...prev, image: true }));
    }
  }

  // ... rest of existing code ...
};
```

---

### Step 6: Remove Old Auto-Agent Code

**File:** `/src/App.jsx` (MODIFY)
**Location:** Lines 1810-1923 (approximately)
**Estimated time:** 0.5 hours
**Priority:** P0

```javascript
// REMOVE these lines (old auto-agent trigger):

// Check if the message suggests user wants background agent work
const needsBackgroundAgent = (
  imageMode ||
  finalTextInput.toLowerCase().includes('pdf') ||
  finalTextInput.toLowerCase().includes('dokument') ||
  ... // rest of old keyword detection
);

if (needsBackgroundAgent) {
  console.log('ğŸ¤– [AGENT] Triggering background agent...');
  // ... old agent calling code ...
}
```

**Replace with:** Code from Step 4 (new orchestration).

---

### Step 7: Update Dependencies

**File:** `package.json` (CHECK - likely no changes needed)
**Estimated time:** 0.5 hours

Verify we have required dependencies:
```json
{
  "dependencies": {
    "@google-cloud/vertexai": "^1.7.0"
  }
}
```

Already installed! âœ… No changes needed.

---

## ğŸ§ª TESTING STRATEGY

### Test Cases

| # | User Message | Expected Intent | Expected Tool Call | Expected Pending | Notes |
|---|--------------|-----------------|--------------------|--------------------|-------|
| **1** | "MÅ¯Å¾u dostat PDF?" | query, pdf_tool, false | âŒ No | pdf: true | Omnia should answer, set pending |
| **2** | "Ano" (after #1) | confirm, pdf_tool, true | âœ… Yes | pdf: false | User confirmed, clear pending |
| **3** | "UdÄ›lej PDF" | request, pdf_tool, true | âœ… Yes | - | Direct request, immediate action |
| **4** | "Jak se mÃ¡Å¡?" | chat, null, false | âŒ No | - | Normal chat, no tools |
| **5** | "Vygeneruj obrÃ¡zek moÅ™e" | request, image_tool, true | âœ… Yes | - | Image generation request |
| **6** | "Ne, dÃ­ky" (after query) | chat, null, false | âŒ No | Reset pending | User rejected, clear state |
| **7** | "hledej dokumentaci pro React" | chat, null, false | âŒ No | - | Search intent, NOT PDF |
| **8** | "MÅ¯Å¾eÅ¡ udÄ›lat logo?" | query, image_tool, false | âŒ No | image: true | Image query, wait for confirm |
| **9** | "Co je to PDF formÃ¡t?" | chat, null, false | âŒ No | - | Discussion, not request |
| **10** | "Exportuj chat" | request, pdf_tool, true | âœ… Yes | - | Implicit PDF request |

---

### Testing Procedure

#### Phase 1: Unit Testing (Local)

**1. Test Intent Classifier endpoint directly:**

```bash
curl -X POST http://localhost:3001/api/intent-classifier \
  -H "Content-Type: application/json" \
  -d '{
    "currentMessage": "MÅ¯Å¾u dostat PDF?",
    "recentContext": [],
    "pendingActions": {}
  }'

# Expected output:
# {"primary_intent":"query","tool_hint":"pdf_tool","explicit_request":false}
```

**2. Test all 10 scenarios above:**

For each test case:
1. Send request to `/api/intent-classifier`
2. Verify JSON output matches expected
3. Check logs for correct reasoning

---

#### Phase 2: Integration Testing (Local)

**Test complete flow in browser:**

**Test 1: Query â†’ Confirm**
```
Steps:
1. Open Omnia chat
2. Send: "MÅ¯Å¾u dostat PDF?"
3. Verify:
   - Omnia answers (no PDF yet)
   - pendingActions.pdf = true (check console)
   - Intent log shows "query"
4. Send: "Ano"
5. Verify:
   - PDF generation starts
   - pendingActions.pdf = false
   - PDF link appears
```

**Test 2: Explicit Request**
```
Steps:
1. Send: "UdÄ›lej PDF z toho"
2. Verify:
   - Omnia starts responding
   - Intent log shows "request"
   - PDF generation starts immediately
   - PDF appears when ready
```

**Test 3: False Positive Prevention**
```
Steps:
1. Send: "hledej dokumentaci pro React"
2. Verify:
   - Omnia searches Google
   - Intent log shows "chat"
   - NO PDF generated
   - Search results shown
```

**Test 4: Normal Chat**
```
Steps:
1. Send: "Jak se mÃ¡Å¡?"
2. Verify:
   - Omnia answers
   - Intent log shows "chat"
   - NO tool agent called
   - Fast response
```

---

#### Phase 3: Monitoring (Production)

**Metrics to track:**

1. **Intent Accuracy**
   - True Positive Rate: Correct tool calls / Total explicit requests
   - False Positive Rate: Incorrect tool calls / Total chats
   - Target: >90% accuracy, <5% false positives

2. **Latency**
   - Intent Classifier response time
   - Target: <300ms

3. **Cost**
   - Daily Intent Classifier cost
   - Daily Tool Agent calls
   - Compare to baseline (before Intent Classifier)

4. **User Feedback**
   - Monitor for confusion (unexpected PDF/image generation)
   - Check for missed requests (user wanted tool, didn't get it)

**Logging:**

Add to Vercel logs:
```javascript
console.log('ğŸ“Š [METRICS] Intent Classification:', {
  intent: intent.primary_intent,
  tool_hint: intent.tool_hint,
  explicit_request: intent.explicit_request,
  latency: Date.now() - startTime,
  user_turn: userTurnId
});

console.log('ğŸ“Š [METRICS] Tool Agent Call:', {
  called: true/false,
  reason: intent.explicit_request ? 'explicit_request' : 'not_needed',
  tool_type: intent.tool_hint
});
```

---

### Success Criteria

**Phase 1 MVP Launch:**

- âœ… Intent accuracy >90%
- âœ… False positive rate <5%
- âœ… Intent Classifier latency <300ms
- âœ… Cost reduction >20%
- âœ… Zero UX degradation
- âœ… Confirmation flow works 100%
- âœ… All 10 test cases pass

**If any criterion fails:**
- Roll back to keyword detection (feature flag)
- Analyze failure logs
- Iterate on prompt or context window

---

## ğŸ“Š SUCCESS METRICS

### Primary Metrics

| Metric | Target | Measurement | Importance |
|--------|--------|-------------|------------|
| **Intent Accuracy** | >90% | Correct classifications / Total | ğŸš¨ HIGH |
| **False Positive Rate** | <5% | Wrong tool calls / Total chats | ğŸš¨ HIGH |
| **False Negative Rate** | <5% | Missed tool requests / Total requests | ğŸš¨ HIGH |
| **Latency** | <300ms | Intent Classifier response time | âš ï¸ MEDIUM |
| **Cost Reduction** | >20% | Monthly savings vs baseline | âœ… LOW |

---

### Secondary Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Confirmation Flow Success** | 100% | Query â†’ Confirm â†’ Tool calls |
| **User Satisfaction** | No degradation | Monitor feedback/complaints |
| **Tool Agent Hit Rate** | 15-25% | Tool calls / Total user turns |
| **Pending Actions Accuracy** | >95% | Correct pending state management |

---

### Monitoring Dashboard

**Daily reports:**

```
ğŸ“Š Intent Classifier Stats (Last 24h):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total classifications:    1,247
Intent breakdown:
  - chat:                 892 (71.5%)
  - request:              198 (15.9%)
  - query:                123 (9.9%)
  - confirm:               34 (2.7%)

Tool Agent calls:         232 (18.6% hit rate)
  - PDF:                  178
  - Image:                 54

Average latency:          247ms
Cost today:               $0.11

False positives detected: 3 (0.24%)
False negatives reported: 1 (0.08%)
```

---

## ğŸš€ DEPLOYMENT PLAN

### Branch Strategy

```
main (production)
  â†“
feature/intent-classifier-mvp (development)
  â†“
Local testing â†’ Staging â†’ Production (gradual rollout)
```

---

### Deployment Steps

#### Step 1: Local Development & Testing
```bash
git checkout -b feature/intent-classifier-mvp
# Implement all code changes
# Test all 10 scenarios locally
# Verify logs and behavior
```

#### Step 2: Staging Deployment
```bash
git push origin feature/intent-classifier-mvp
# Deploy to Vercel preview environment
# Run full integration tests
# Monitor for 2-4 hours
```

#### Step 3: Production Deployment (Gradual Rollout)

**Phase A: Monitoring Only (Day 1-2)**
```javascript
// Feature flag in Vercel environment variables
INTENT_CLASSIFIER_ENABLED=true
INTENT_CLASSIFIER_MODE=monitor  // Log only, don't act

// Code:
if (process.env.INTENT_CLASSIFIER_MODE === 'monitor') {
  console.log('[MONITOR] Intent result:', intent);
  // Don't use result, continue with old behavior
}
```

**Phase B: 10% Rollout (Day 3-4)**
```javascript
INTENT_CLASSIFIER_MODE=active
INTENT_CLASSIFIER_ROLLOUT_PERCENT=10

// Code:
const userRollout = hashUserId(userId) % 100;
if (userRollout < process.env.INTENT_CLASSIFIER_ROLLOUT_PERCENT) {
  // Use Intent Classifier
} else {
  // Use old keyword detection
}
```

**Phase C: 50% Rollout (Day 5-6)**
```javascript
INTENT_CLASSIFIER_ROLLOUT_PERCENT=50
```

**Phase D: 100% Rollout (Day 7+)**
```javascript
INTENT_CLASSIFIER_ROLLOUT_PERCENT=100
// Remove old keyword detection code
```

---

### Rollback Plan

**Immediate rollback (if critical issues):**

```bash
# Option 1: Vercel environment variable
INTENT_CLASSIFIER_ENABLED=false
# Redeploy in <2 minutes

# Option 2: Git revert
git revert <commit-hash>
git push origin main
# Redeploy in <5 minutes
```

**Partial rollback (if minor issues):**

```javascript
// Reduce rollout percentage
INTENT_CLASSIFIER_ROLLOUT_PERCENT=10  // Back to 10%
```

---

### Monitoring Plan

**During rollout, monitor:**

1. **Error rates** - Any 500s from `/api/intent-classifier`?
2. **Latency** - Intent Classifier response time <300ms?
3. **User feedback** - Any confusion/complaints?
4. **Cost** - Daily cost tracking vs baseline
5. **False positives** - Tool Agent calls that shouldn't happen
6. **False negatives** - Users complaining "PDF didn't generate"

**Alert conditions:**

```
ğŸš¨ CRITICAL (immediate rollback):
- Error rate >10%
- Latency >1000ms (p95)
- False positive rate >15%

âš ï¸ WARNING (investigate, possible rollback):
- Error rate >5%
- Latency >500ms (p95)
- False positive rate >10%
- User complaints >3 in 24h
```

---

## â±ï¸ IMPLEMENTATION TIMELINE

### Detailed Breakdown

| Step | Task | Time | Priority | Blocker | Assignee |
|------|------|------|----------|---------|----------|
| 1 | Create Intent Classifier endpoint | 2-3h | P0 | - | Dev |
| 2 | Create Intent Classifier prompt | 1-2h | P0 | Step 1 | Dev |
| 3 | Add pendingActions state | 0.5h | P0 | - | Dev |
| 4 | Update handleSend orchestration | 2-3h | P0 | Steps 1-3 | Dev |
| 5 | Add pending detection in stream | 1h | P1 | Step 3 | Dev |
| 6 | Remove old auto-agent code | 0.5h | P0 | Step 4 | Dev |
| 7 | Local testing (10 scenarios) | 2h | P0 | All above | Dev |
| 8 | Integration testing | 1h | P0 | Step 7 | Dev |
| 9 | Code review | 1h | P1 | Step 8 | Team |
| 10 | Staging deployment | 0.5h | P0 | Step 9 | Dev |
| 11 | Staging testing | 1h | P0 | Step 10 | Dev |
| 12 | Production deployment | 0.5h | P0 | Step 11 | Dev |
| 13 | Monitoring (24h) | - | P0 | Step 12 | Team |

**Total:** 10-14 hours (1.5-2 days of focused work)

---

### Day-by-Day Plan

**Day 1: Development (6-8h)**
```
Morning:
- [ ] Create Intent Classifier endpoint (2-3h)
- [ ] Create Intent Classifier prompt (1-2h)

Afternoon:
- [ ] Add pendingActions state (0.5h)
- [ ] Update handleSend orchestration (2-3h)
```

**Day 2: Testing & Deployment (4-6h)**
```
Morning:
- [ ] Add pending detection in stream (1h)
- [ ] Remove old auto-agent code (0.5h)
- [ ] Local testing (2h)

Afternoon:
- [ ] Integration testing (1h)
- [ ] Code review (1h)
- [ ] Staging deployment + testing (1.5h)
```

**Day 3+: Monitoring (ongoing)**
```
- [ ] Production deployment (0.5h)
- [ ] Monitor for 24h
- [ ] Gradual rollout (if successful)
```

---

## ğŸ¯ PHASE 2 PREVIEW (FUTURE)

After Phase 1 MVP is successful, Phase 2 will add **advanced security features**.

### Phase 2 Goals

1. **Enhanced Security Layer**
   - Prompt injection detection
   - Context poisoning prevention
   - Threat classification (low/medium/high)

2. **Threat Logging to Summarization Agent**
   - Security events logged in chat summaries
   - Persistent threat tracking
   - Pattern detection across conversations

3. **Proactive User Education**
   - When threat detected, Omnia explains what happened
   - Educational responses ("This looks like a prompt injection...")
   - No shaming, just transparency

4. **Dynamic Context Window**
   - Simple chat: 3-5 messages (fast, cheap)
   - Complex workflow (editing): 20+ messages (more context)
   - Auto-adjust based on scenario

5. **More Tool Types**
   - Image editing (not just generation)
   - Chart generation (QuickChart integration)
   - Video generation (future)

### Phase 2 Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Intent Classifier (Enhanced)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Intent Detection (existing)                                   â”‚
â”‚ 2. Security Analysis (NEW)                                       â”‚
â”‚    â”œâ”€ Prompt injection detection                                â”‚
â”‚    â”œâ”€ Context poisoning check                                   â”‚
â”‚    â””â”€ Threat classification                                     â”‚
â”‚ 3. Threat Logging (NEW)                                          â”‚
â”‚    â””â”€ Send to Summarization Agent                               â”‚
â”‚ 4. Dynamic Context (NEW)                                         â”‚
â”‚    â””â”€ Adjust window size based on scenario                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase 2 Timeline

**Estimated:** 2-3 weeks after Phase 1 success

**Benefits:**
- ğŸ”’ Enhanced security (protect against attacks)
- ğŸ“Š Better threat visibility (know what's happening)
- ğŸ“ User education (transparency builds trust)
- âš¡ Performance optimization (dynamic context)

---

## ğŸ“ STATUS TRACKING

### Implementation Checklist

- [ ] **Documentation**
  - [x] INTENT_CLASSIFIER.md created
  - [ ] ARCHITECTURE.md updated
  - [ ] Team reviewed

- [ ] **Code Changes**
  - [ ] `/api/intent-classifier.js` created
  - [ ] `/src/prompts/intent-classifier.js` created
  - [ ] `/src/App.jsx` - pendingActions state added
  - [ ] `/src/App.jsx` - handleSend updated
  - [ ] `/src/App.jsx` - pending detection added
  - [ ] `/src/App.jsx` - old code removed

- [ ] **Testing**
  - [ ] Unit tests (10 scenarios)
  - [ ] Integration tests (local)
  - [ ] Staging tests
  - [ ] Production monitoring (24h)

- [ ] **Deployment**
  - [ ] Local development complete
  - [ ] Staging deployed
  - [ ] Production deployed (monitoring mode)
  - [ ] Production deployed (10% rollout)
  - [ ] Production deployed (50% rollout)
  - [ ] Production deployed (100% rollout)

- [ ] **Monitoring**
  - [ ] Metrics dashboard setup
  - [ ] Alert conditions configured
  - [ ] Daily reports generated
  - [ ] Week 1 analysis complete

---

### Version History

| Version | Date | Changes | Author |
|---------|------|---------|--------|
| 1.0 | 2025-01-16 | Initial documentation | Cristian + Claude |
| - | - | (Implementation pending) | - |

---

### References

- [Gemini 2.0 Flash Lite Docs](https://cloud.google.com/vertex-ai/docs/generative-ai/model-reference/gemini)
- [Vertex AI Pricing](https://cloud.google.com/vertex-ai/pricing)
- [Omnia Architecture Docs](./ARCHITECTURE.md)
- [Background Agent Implementation](../api/background-agent.js)

---

**Last updated:** 2025-01-16
**Status:** âœ… Documentation complete, ready for implementation
**Next step:** Create `/api/intent-classifier.js` endpoint

---

**END OF DOCUMENT**
